# OKX 资金费率套利全自动机器人（2025 年 11 月版）

## 策略简介
利用永续合约资金费率机制，通过现货 + 合约对冲涨跌，只吃每 8 小时结算的资金费率（多头或空头送的钱）。  
当前（2025.11.18）ETH 资金费率处于低位/轻微负，正适合开机器人自动吃钱。

- 本金建议：50~300 USDT 起步
- 杠杆建议：1.5~2.0x（50 USDT 建议 1.8x）
- 预期收益：当前低费率日赚 0.1~0.5 USDT，费率回升后日赚 0.5~2+ USDT
- 风险：极低（2x 杠杆下爆仓需单边暴跌 50%+，历史上极少）

## 核心原理
| 资金费率 | 机器人仓位                         | 你吃谁的钱   |
|----------|------------------------------------|--------------|
| 正费率   | 现货持 ETH + 合约做空（超额）      | 吃多头钱    |
| 负费率   | 现货卖 USDT + 合约做多（超额）     | 吃空头钱    |

机器人每 10 分钟检查一次，实现**自动翻仓**，永远站在被付钱的一方。

## 完整代码（okx_funding_bot.py）

```python
# -*- coding: utf-8 -*-
import okx
import time
import requests
from datetime import datetime

# ================== 请修改这几行 ==================
API_KEY = '你的API Key'
SECRET_KEY = '你的Secret Key'
PASSPHRASE = '你的Passphrase'

TELEGRAM_TOKEN = '你的Telegram Bot Token'   # 可留空不填
TELEGRAM_CHAT_ID = '你的chat_id'            # 可留空不填

SYMBOL = 'ETH-USDT'                         # 改 BTC 就写 BTC-USDT
LEVERAGE = 1.8                              # 50刀建议1.8，300刀可开到2.0
TARGET_DELTA = 0.98                         # 轻微超额吃更多费率
# ================================================

flag = '0'  # 先改成 '0' 仿盘测试48小时！！！测试OK后再改 '1' 实盘
market_api = okx.MarketData(flag=flag)
account_api = okx.Account(flag=flag)
trade_api = okx.Trade(flag=flag)

def send_telegram(msg):
    if not TELEGRAM_TOKEN: return
    try:
        url = f"https://api.telegram.org/bot{TELEGRAM_TOKEN}/sendMessage"
        requests.post(url, data={'chat_id': TELEGRAM_CHAT_ID, 'text': msg}, timeout=10)
    except: pass

def get_funding_rate():
    resp = market_api.get_funding_rate(instId=f'{SYMBOL}-SWAP')
    return float(resp['data'][0]['fundingRate'])

def get_price():
    ticker = market_api.get_ticker(instId=f'{SYMBOL}-SWAP')
    return float(ticker['data'][0]['last'])

def get_spot_balance():
    resp = account_api.get_account_balance()
    for item in resp['data'][0]['details']:
        if item['ccy'] == SYMBOL.split('-')[0]:
            return float(item['availBal'])
    return 0

def get_futures_position():
    resp = account_api.get_positions(instType='SWAP', instId=f'{SYMBOL}-SWAP')
    if resp['data']:
        pos = resp['data'][0]
        return pos['posSide'], float(pos['pos'])
    return None, 0

def close_all_futures():
    side, size = get_futures_position()
    if size > 0:
        trade_api.place_order(
            instId=f'{SYMBOL}-SWAP', tdMode='cross', 
            side='sell' if side=='long' else 'buy', 
            ordType='market', sz=size)

def rebalance():
    price = get_price()
    spot_eth = get_spot_balance()
    spot_value = spot_eth * price
    target_futures_value = spot_value * LEVERAGE * TARGET_DELTA

    funding_rate = get_funding_rate()
    send_telegram(f"当前资金费率: {funding_rate*100:.4f}%   价格: {price:.2f}")

    desired_side = 'short' if funding_rate > 0.0001 else 'long'  # 正费率做空，负费率做多

    current_side, current_size = get_futures_position()
    current_value = current_size * price

    # 方向不对或偏差>5%就重开
    if (desired_side == 'short' and current_side == 'long') or \
       (desired_side == 'long' and current_side == 'short') or \
       abs(current_value - target_futures_value) > spot_value * 0.05:

        if (desired_side == 'short' and current_side == 'long') or \
           (desired_side == 'long' and current_side == 'short'):
            send_telegram("费率反转！正在自动翻仓...")

        close_all_futures()
        time.sleep(3)

        sz = f"{target_futures_value / price:.6f}"
        side = 'sell' if desired_side == 'short' else 'buy'
        posSide = 'short' if desired_side == 'short' else 'long'
        
        trade_api.place_order(
            instId=f'{SYMBOL}-SWAP', tdMode='cross', side=side,
            posSide=posSide, ordType='market', sz=sz)
        
        send_telegram(f"仓位已平衡 → {desired_side.upper()}，目标价值 ≈${target_futures_value:.1f}")

# 主循环
last_day = None
while True:
    try:
        now = datetime.now()
        if last_day != now.day:
            send_telegram(f"【{now.strftime('%Y-%m-%d')}】机器人正常运行，准备收今天费率～")
            last_day = now.day
        rebalance()
        time.sleep(600)  # 10分钟一次
    except Exception as e:
        send_telegram(f"出错: {str(e)}")
        time.sleep(60)