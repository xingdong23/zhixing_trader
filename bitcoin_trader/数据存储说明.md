# 数据存储说明

## 当前状态：没有数据库 ❌

目前的策略**不会**将交易数据插入数据库。所有数据都存储在内存中。

## 当前数据存储方式

### 1. 内存存储
交易数据存储在Python对象的属性中：

```python
class HighFrequencyScalpingStrategy:
    def __init__(self):
        self.daily_trades = []  # 今日交易列表（内存）
        self.daily_pnl = 0.0    # 今日盈亏（内存）
        self.current_position = None  # 当前持仓（内存）
```

### 2. 日志文件
交易信息会记录到日志文件：

```
logs/high_frequency_20251025.log
```

日志内容示例：
```
2025-10-25 19:34:08,497 - __main__ - INFO - ✓ [模拟盘] 做多开仓成功: {...}
2025-10-25 19:34:08,497 - __main__ - INFO - 记录交易: {...}
2025-10-25 19:34:08,497 - __main__ - INFO - 📊 策略统计: 今日交易=1, 胜率=100.0%, 盈亏=5.50 USDT
```

## 数据生命周期

### ⚠️ 程序重启后数据丢失
- 所有交易记录在内存中
- 程序停止后数据清空
- 重启后从零开始

### ⚠️ 每日重置
- 每天0点自动重置统计
- `daily_trades` 清空
- `daily_pnl` 归零
- 连续亏损次数重置

## 当前记录的数据

### 策略记录
```python
def record_trade(self, signal: Dict[str, Any]):
    trade = {
        "timestamp": datetime.now(),
        "signal": signal["signal"],      # buy/sell
        "price": signal["price"],        # 价格
        "amount": signal.get("amount", 0),  # 数量
        "type": signal.get("type", "entry"),  # entry/exit
        "pnl": signal.get("pnl", 0),     # 盈亏
        "reason": signal.get("reason", "")  # 原因
    }
    self.daily_trades.append(trade)  # 只存在内存中
```

### 风险管理器记录
```python
def record_trade(self, trade: Dict[str, Any]):
    self.daily_trades.append({
        "timestamp": datetime.now(),
        "symbol": trade["symbol"],
        "side": trade["side"],
        "amount": trade["amount"],
        "price": trade["price"],
        "pnl": trade.get("pnl", 0)
    })
    # 也只存在内存中
```

## 如果需要数据库

### 方案1: SQLite（简单）
适合个人使用，数据存储在本地文件

```python
import sqlite3

def init_database():
    conn = sqlite3.connect('trades.db')
    cursor = conn.cursor()
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS trades (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            timestamp DATETIME,
            symbol TEXT,
            signal TEXT,
            price REAL,
            amount REAL,
            pnl REAL,
            reason TEXT
        )
    ''')
    conn.commit()
    conn.close()

def save_trade_to_db(trade):
    conn = sqlite3.connect('trades.db')
    cursor = conn.cursor()
    cursor.execute('''
        INSERT INTO trades (timestamp, symbol, signal, price, amount, pnl, reason)
        VALUES (?, ?, ?, ?, ?, ?, ?)
    ''', (
        trade['timestamp'],
        trade['symbol'],
        trade['signal'],
        trade['price'],
        trade['amount'],
        trade['pnl'],
        trade['reason']
    ))
    conn.commit()
    conn.close()
```

### 方案2: PostgreSQL（专业）
适合生产环境，支持高并发

```python
import psycopg2

def save_trade_to_postgres(trade):
    conn = psycopg2.connect(
        host="localhost",
        database="trading",
        user="trader",
        password="password"
    )
    cursor = conn.cursor()
    cursor.execute('''
        INSERT INTO trades (timestamp, symbol, signal, price, amount, pnl, reason)
        VALUES (%s, %s, %s, %s, %s, %s, %s)
    ''', (
        trade['timestamp'],
        trade['symbol'],
        trade['signal'],
        trade['price'],
        trade['amount'],
        trade['pnl'],
        trade['reason']
    ))
    conn.commit()
    cursor.close()
    conn.close()
```

### 方案3: CSV文件（最简单）
适合快速记录和Excel分析

```python
import csv
from datetime import datetime

def save_trade_to_csv(trade):
    filename = f"trades_{datetime.now().strftime('%Y%m%d')}.csv"
    
    # 检查文件是否存在
    file_exists = os.path.isfile(filename)
    
    with open(filename, 'a', newline='') as f:
        writer = csv.DictWriter(f, fieldnames=[
            'timestamp', 'symbol', 'signal', 'price', 'amount', 'pnl', 'reason'
        ])
        
        # 如果是新文件，写入表头
        if not file_exists:
            writer.writeheader()
        
        writer.writerow(trade)
```

## 优缺点对比

| 方案 | 优点 | 缺点 | 适用场景 |
|------|------|------|---------|
| 内存（当前） | 简单快速 | 数据丢失 | 测试阶段 |
| 日志文件 | 自动记录 | 难以查询 | 调试分析 |
| CSV文件 | 简单易用 | 性能较低 | 个人使用 |
| SQLite | 轻量级 | 单机使用 | 个人/小型 |
| PostgreSQL | 功能强大 | 配置复杂 | 生产环境 |

## 建议

### 当前阶段（测试）
✅ **保持现状**
- 内存存储足够
- 日志文件可查看
- 简单高效

### 如果需要持久化
✅ **推荐CSV文件**
- 最简单实现
- 可用Excel分析
- 适合个人使用

### 如果需要专业化
✅ **推荐SQLite**
- 轻量级数据库
- 支持SQL查询
- 数据持久化

## 是否需要添加数据库？

**目前不需要**，因为：
1. ✅ 日志文件已经记录了所有信息
2. ✅ 策略在测试阶段
3. ✅ 每日统计已经足够
4. ✅ 保持代码简洁

**如果你需要**：
- 长期数据分析
- 回测历史交易
- 多策略对比
- 生成报表

那么可以考虑添加数据库功能。

## 查看交易记录

### 方法1: 查看日志文件
```bash
# 查看今天的日志
cat logs/high_frequency_20251025.log

# 搜索交易记录
grep "做多开仓\|做空开仓" logs/high_frequency_20251025.log

# 搜索盈亏
grep "策略统计" logs/high_frequency_20251025.log
```

### 方法2: 实时监控
```bash
# 实时查看日志
tail -f logs/high_frequency_20251025.log
```

## 总结

✅ **当前状态**
- 无数据库
- 内存存储
- 日志记录
- 每日重置

⚠️ **注意事项**
- 程序重启数据丢失
- 每日0点自动重置
- 只能查看当天数据

📝 **如需持久化**
- 可以添加CSV导出
- 可以添加SQLite
- 可以添加PostgreSQL

目前的设计适合测试和个人使用，如果需要添加数据库功能，请告诉我！
